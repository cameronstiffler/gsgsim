--- a/gsgsim/engine.py
+++ b/gsgsim/engine.py
@@ -2,6 +2,7 @@
 from typing import Optional, Callable, List, Tuple
 from .models import GameState, Player
 from .payments import distribute_wind
+from .abilities import use_ability
 
 Chooser = Callable[[List[Tuple[int, object, int]], int], Optional[List[Tuple[int, int]]]]
 

--- a/gsgsim/payments.py
+++ b/gsgsim/payments.py
@@ -1,73 +1,75 @@
 from __future__ import annotations
-from typing import List, Optional, Tuple, Callable
-from .models import Card, Player
-from .rules import destroy_if_needed
+from typing import List, Tuple, Optional, Callable
+from .models import Player, Card
 
 Chooser = Callable[[List[Tuple[int, Card, int]], int], Optional[List[Tuple[int, int]]]]
 
-def _eligible_with_caps(owner: Player) -> List[Tuple[int, Card, int]]:
+def _eligible_with_caps(player: Player) -> List[Tuple[int, Card, int]]:
     out: List[Tuple[int, Card, int]] = []
-    for idx, c in enumerate(owner.board):
+    for idx, c in enumerate(getattr(player, "board", [])):
         if getattr(c, "new_this_turn", False):
             setattr(c, "_why_ineligible", "new this turn")
             continue
-        cap = max(0, 4 - getattr(c, "wind", 0))
-        out.append((idx, c, cap))
+        wind = getattr(c, "wind", 0)
+        cap = max(0, 4 - wind)
+        if cap > 0:
+            out.append((idx, c, cap))
     return out
 
 def _auto_plan(eligible: List[Tuple[int, Card, int]], total_cost: int) -> Optional[List[Tuple[int, int]]]:
-    if sum(cap for _, _, cap in eligible) < total_cost:
-        return None
+    if total_cost <= 0:
+        return []
+
+    def is_sl(card: Card) -> bool:
+        r = getattr(card, "rank", None)
+        if isinstance(r, str):
+            return r.upper() == "SL"
+        return str(getattr(r, "name", "")).upper() == "SL"
+
+    non_sl = []
+    sls = []
+    for i,c,cap in eligible:
+        (sls if is_sl(c) else non_sl).append((i,c,cap))
+
     plan: List[Tuple[int, int]] = []
-    caps = [cap for _, _, cap in eligible]
-    i = 0; remaining = total_cost; n = len(eligible)
-    while remaining > 0:
-        if caps[i] > 0:
-            idx = eligible[i][0]
-            plan.append((idx, 1))
-            caps[i] -= 1
-            remaining -= 1
-        i = (i + 1) % n
-    return plan
+    need = total_cost
 
-def _validate_plan(eligible: List[Tuple[int, Card, int]], total_cost: int, plan: List[Tuple[int, int]]) -> bool:
-    totals = {}
-    for idx, amt in plan:
-        if amt <= 0: return False
-        totals[idx] = totals.get(idx, 0) + amt
-    if sum(totals.values()) != total_cost: return False
-    caps = {idx: cap for idx, _, cap in eligible}
-    for idx, amt in totals.items():
-        if idx not in caps: return False
-        if amt > caps[idx]: return False
-    return True
+    for i,c,cap in non_sl:
+        if need == 0: break
+        take = min(cap, need)
+        if take > 0:
+            plan.append((i, take)); need -= take
+    if need == 0: return plan
 
-def distribute_wind(owner: Player, total_cost: int, *, auto: bool = True, chooser: Optional[Chooser] = None, allow_cancel: bool = False) -> Optional[bool]:
-    if total_cost <= 0: return True
-    eligible = _eligible_with_caps(owner)
-    if not eligible:
-        # explain why
-        reasons = []
-        for c in owner.board:
-            if getattr(c, "new_this_turn", False):
-                reasons.append(f"{getattr(c, 'name', 'Goon')}: new this turn")
-        msg = "No eligible goons to pay wind."
-        if reasons:
-            msg += " (" + "; ".join(reasons) + ")"
-        print(msg)
-        return False
-    if sum(cap for _, _, cap in eligible) < total_cost: return False
+    for i,c,cap in sls:
+        if need == 0: break
+        current = getattr(c, "wind", 0)
+        safe_cap = max(0, 3 - current)
+        take = min(safe_cap, need)
+        if take > 0:
+            plan.append((i, take)); need -= take
+    if need == 0: return plan
+
+    return None
+
+def distribute_wind(player: Player, total_cost: int, chooser: Optional[Chooser] = None) -> bool:
+    if total_cost <= 0:
+        return True
+
+    eligible = _eligible_with_caps(player)
+    have = sum(cap for _,_,cap in eligible)
+    if have < total_cost:
+        print("could not pay wind"); return False
+
     if chooser is not None:
         plan = chooser(eligible, total_cost)
-        if plan is None: return False
     else:
         plan = _auto_plan(eligible, total_cost)
-        if plan is None: return False
-    if not _validate_plan(eligible, total_cost, plan): return False
-    idx_to_card = {i: c for i, c, _ in eligible}
+
+    if not plan:
+        print("could not pay wind"); return False
+
     for idx, amt in plan:
-        card = idx_to_card[idx]
+        card = player.board[idx]
         card.wind = getattr(card, "wind", 0) + amt
-    for c in list(owner.board):
-        destroy_if_needed(owner, c)
     return True

--- a/gsgsim/ui/rich_ui.py
+++ b/gsgsim/ui/rich_ui.py
@@ -114,3 +114,10 @@
             if m: deploy_from_hand(gs, gs.turn_player, int(m.group(1))); continue
             m = re.fullmatch(r"dd(\d+)", line)
             if m: deploy_from_hand(gs, gs.turn_player, int(m.group(1))); continue
+
+m = re.fullmatch(r"u\s+(\d+)\s+(\d+)", line)
+if m:
+    src = int(m.group(1)); abil = int(m.group(2))
+    from ..engine import use_ability_cli
+    use_ability_cli(gs, src, abil)
+    continue

